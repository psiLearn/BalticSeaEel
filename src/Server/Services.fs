namespace Eel.Server.Services

open System
open System.Collections.Generic
open System.Data.Common
open System.IO
open System.Text
open System.Threading
open Microsoft.VisualBasic.FileIO
open Npgsql
open Serilog
open Shared

type IScoreRepository =
    abstract member GetScores: unit -> HighScore list
    abstract member GetTopScore: unit -> HighScore option
    abstract member UpsertScore: HighScore -> HighScore

type InMemoryScoreRepository() =
    let mutable storage: HighScore list = []
    let syncRoot = obj()

    let ordered () =
        storage
        |> List.sortByDescending (fun score -> score.Score)
        |> List.truncate 10

    interface IScoreRepository with
        member _.GetScores() =
            lock syncRoot ordered

        member _.GetTopScore() =
            lock syncRoot (fun () -> ordered () |> List.tryHead)

        member _.UpsertScore score =
            lock syncRoot (fun () ->
                storage <- { Name = score.Name; Score = score.Score } :: storage
                score)

type PostgresScoreRepository(connectionString: string) =
    let ensureSchema () =
        use conn = new NpgsqlConnection(connectionString)
        conn.Open()
        use cmd = conn.CreateCommand()
        cmd.CommandText <- """
            CREATE TABLE IF NOT EXISTS scores (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                name TEXT NOT NULL,
                score INTEGER NOT NULL
            );
        """
        cmd.ExecuteNonQuery() |> ignore

        use ensureId = conn.CreateCommand()
        ensureId.CommandText <- """
            DO $$
            BEGIN
                IF NOT EXISTS (
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_name = 'scores' AND column_name = 'id'
                ) THEN
                    ALTER TABLE scores
                    ADD COLUMN id BIGINT GENERATED BY DEFAULT AS IDENTITY;
                END IF;
            END $$;
        """
        ensureId.ExecuteNonQuery() |> ignore

        use dropPk = conn.CreateCommand()
        dropPk.CommandText <- "ALTER TABLE scores DROP CONSTRAINT IF EXISTS scores_pkey;"
        dropPk.ExecuteNonQuery() |> ignore

        use addPk = conn.CreateCommand()
        addPk.CommandText <- "ALTER TABLE scores ADD CONSTRAINT scores_pkey PRIMARY KEY (id);"
        addPk.ExecuteNonQuery() |> ignore

        use enforceName = conn.CreateCommand()
        enforceName.CommandText <- "ALTER TABLE scores ALTER COLUMN name SET NOT NULL;"
        enforceName.ExecuteNonQuery() |> ignore

    do ensureSchema ()

    let readScores (reader: DbDataReader) =
        let name = reader.GetString(0)
        let score = reader.GetInt32(1)
        { Name = name; Score = score }

    interface IScoreRepository with
        member _.GetScores() =
            use conn = new NpgsqlConnection(connectionString)
            conn.Open()
            use cmd = conn.CreateCommand()
            cmd.CommandText <- "SELECT name, score FROM scores ORDER BY score DESC, id ASC LIMIT 10;"
            use reader = cmd.ExecuteReader()
            let scores = ResizeArray()
            while reader.Read() do
                scores.Add(readScores reader)
            scores |> Seq.toList

        member _.GetTopScore() =
            use conn = new NpgsqlConnection(connectionString)
            conn.Open()
            use cmd = conn.CreateCommand()
            cmd.CommandText <- "SELECT name, score FROM scores ORDER BY score DESC LIMIT 1;"
            use reader = cmd.ExecuteReader()
            if reader.Read() then
                Some (readScores reader)
            else
                None

        member _.UpsertScore score =
            use conn = new NpgsqlConnection(connectionString)
            conn.Open()
            use cmd = conn.CreateCommand()
            cmd.CommandText <- """
                INSERT INTO scores(name, score)
                VALUES (@name, @score)
                RETURNING name, score;
            """
            cmd.Parameters.AddWithValue("@name", score.Name) |> ignore
            cmd.Parameters.AddWithValue("@score", score.Score) |> ignore
            use reader = cmd.ExecuteReader()
            if reader.Read() then
                readScores reader
            else
                score

type HighScoreStore(repository: IScoreRepository) =
    let sanitizeName (name: string) =
        let trimmed =
            if obj.ReferenceEquals(name, null) then
                ""
            else
                name.Trim()

        if String.IsNullOrWhiteSpace trimmed then "Anonymous" else trimmed

    let sanitizeScore score = max 0 score

    let defaultScore = { Name = "Anonymous"; Score = 0 }

    member _.Get() = repository.GetTopScore() |> Option.defaultValue defaultScore

    member _.GetAll() =
        match repository.GetScores() with
        | [] -> [ defaultScore ]
        | scores -> scores

    member _.Upsert candidate =
        let sanitized =
            { Name = sanitizeName candidate.Name
              Score = sanitizeScore candidate.Score }

        repository.UpsertScore sanitized
type IVocabularyRepository =
    abstract member GetRandom: unit -> VocabularyEntry option

module VocabularySeed =
    let private readFileWithEncoding (path: string) =
        let bytes = File.ReadAllBytes path
        let utf8 = UTF8Encoding(false, true)

        try
            utf8.GetString bytes
        with :? DecoderFallbackException ->
            let latin = Encoding.GetEncoding("windows-1252")
            latin.GetString bytes

    let loadFromCsv (path: string) =
        if String.IsNullOrWhiteSpace path || not (File.Exists path) then
            []
        else
            let content = readFileWithEncoding path
            use reader = new StringReader(content)
            use parser = new TextFieldParser(reader)
            parser.SetDelimiters([| "," |])
            parser.HasFieldsEnclosedInQuotes <- true
            parser.TrimWhiteSpace <- true

            if not parser.EndOfData then
                parser.ReadFields() |> ignore

            let entries = ResizeArray()
            while not parser.EndOfData do
                match parser.ReadFields() with
                | null -> ()
                | fields when fields.Length >= 4 ->
                    let topic = fields[0].Trim()
                    let language1 = fields[1].Trim()
                    let language2 = fields[2].Trim()
                    let example = fields[3].Trim()

                    if
                        not (String.IsNullOrWhiteSpace topic)
                        && not (String.IsNullOrWhiteSpace language1)
                        && not (String.IsNullOrWhiteSpace language2)
                        && not (String.IsNullOrWhiteSpace example)
                    then
                        entries.Add(
                            { Topic = topic
                              Language1 = language1
                              Language2 = language2
                              Example = example }
                        )
                | _ -> ()

            entries |> Seq.toList

type PostgresVocabularyRepository(connectionString: string, seedData: VocabularyEntry list) =
    let ensureSchema () =
        use conn = new NpgsqlConnection(connectionString)
        conn.Open()
        use cmd = conn.CreateCommand()
        cmd.CommandText <- """
            CREATE TABLE IF NOT EXISTS vocabulary (
                id SERIAL PRIMARY KEY,
                topic TEXT NOT NULL,
                language1 TEXT NOT NULL,
                language2 TEXT NOT NULL,
                example TEXT NOT NULL
            );
        """
        cmd.ExecuteNonQuery() |> ignore

    let seed () =
        if List.isEmpty seedData then
            ()
        else
            use conn = new NpgsqlConnection(connectionString)
            conn.Open()
            use countCmd = conn.CreateCommand()
            countCmd.CommandText <- "SELECT COUNT(*) FROM vocabulary;"
            let count = countCmd.ExecuteScalar() :?> int64

            if count = 0L then
                Log.Information("Seeding {Count} vocabulary entries.", seedData.Length)
                use tx = conn.BeginTransaction()
                for entry in seedData do
                    use insert = conn.CreateCommand()
                    insert.Transaction <- tx
                    insert.CommandText <- """
                        INSERT INTO vocabulary(topic, language1, language2, example)
                        VALUES (@topic, @language1, @language2, @example);
                    """
                    insert.Parameters.AddWithValue("@topic", entry.Topic) |> ignore
                    insert.Parameters.AddWithValue("@language1", entry.Language1) |> ignore
                    insert.Parameters.AddWithValue("@language2", entry.Language2) |> ignore
                    insert.Parameters.AddWithValue("@example", entry.Example) |> ignore
                    insert.ExecuteNonQuery() |> ignore
                tx.Commit()

    let readEntry (reader: DbDataReader) =
        { Topic = reader.GetString(0)
          Language1 = reader.GetString(1)
          Language2 = reader.GetString(2)
          Example = reader.GetString(3) }

    do
        ensureSchema ()
        seed ()

    interface IVocabularyRepository with
        member _.GetRandom() =
            use conn = new NpgsqlConnection(connectionString)
            conn.Open()
            use cmd = conn.CreateCommand()
            cmd.CommandText <- """
                SELECT topic, language1, language2, example
                FROM vocabulary
                ORDER BY RANDOM()
                LIMIT 1;
            """
            use reader = cmd.ExecuteReader()
            if reader.Read() then
                Some(readEntry reader)
            else
                None
